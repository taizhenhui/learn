# my-site 项目总结

## icon的使用

> 阿里巴巴矢量图标iconfont的使用

选择图标加入【购物车】-- 【添加至项目】-- 【可添加以后项目中 / 新建项目】

例：

<img src="imgs\image-20230328141155715.png" alt="image-20230328141155715" style="zoom: 67%;" />

- 引用样式

  ```css
  @import "//at.alicdn.com/t/font_2164449_nalfgtq7il.css";
  .iconfont {
    color: inherit;
    font-size: inherit;
  }
  ```

  

- 类名映射

  ```js
  const classMap = {
    home: "iconzhuye",
    success: "iconzhengque",
    error: "iconcuowu",
    close: "iconguanbi",
    warn: "iconjinggao",
    info: "iconxinxi",
    blog: "iconblog",
    code: "iconcode",
    about: "iconset_about_hov",
    weixin: "iconweixin",
    mail: "iconemail",
    github: "icongithub",
    qq: "iconsign_qq",
    arrowUp: "iconiconfonticonfonti2copy",
    arrowDown: "iconiconfonticonfonti2",
    empty: "iconempty",
    chat: "iconliuyan",
  };
  ```

  

- 使用

  ```html
  <template>
    <i class="iconfont icon-container" :class="fontClass"></i>
  </template>
  <script>
  export default {
    computed: {
      // 图标类样式
      fontClass() {
        return classMap[this.type];
      },
    },
  };
  </script>
  ```

  

## 混入的使用

> 抽离公共部分，提高代码复用

#### 创建

1. 可直接导出对象

   > ##### 例：
   >
   > ```js
   > export default {
   >     data() {
   >       return {
   >         isLoading: true,
   >         datas: defaultDataValue
   >       }
   >     },
   >     async created() {
   >       this.datas = await this.fetchData();
   >       this.isLoading = false;
   >     }
   > }
   > ```
   >
   > 

2. 需要传参可写函数 返回对象

   

   > ##### 例：
   >
   > ```js
   > 
   > export default function (refVal) {
   >   return {
   >     methods: {
   >       handleMainScroll() {
   >         this.$bus.$emit('mainScroll', this.$refs[refVal])
   >       },
   >       handleSetMainScroll(scrollTop) {
   >         this.$refs[refVal].scrollTop = scrollTop
   >       }
   >     },
   >     mounted() {
   >       this.$bus.$on('setMainScroll', this.handleSetMainScroll)
   >       this.$refs[refVal].addEventListener('scroll', this.handleMainScroll)
   >     },
   >     beforeDestroy() {
   >       this.$bus.$off('setMainScroll', this.handleSetMainScroll)
   >       this.$bus.$emit('mainScroll')
   >       this.$refs[refVal].removeEventListener('scroll', this.handleMainScroll)
   >     },
   >   }
   > }
   > ```
   >
   > 

#### 使用

1. 对象

   > ##### 例：
   >
   > ```js
   > // 导入
   > import fetchData from '@/mixins/fetchData'
   > 
   > mixins: [fetchData],
   > ```

2. 函数

   > ##### 例：
   >
   > ```js
   > // 导入
   > import mainScroll from '@/mixins/mainScroll'
   > 
   > mixins: [mainScroll('mainContainer')],
   > ```
   >
   > 





## 自定义指令



### 图片懒加载

创建

```js
import $bus from '@/eventBus'
import debounce from '@/utils/debounce'
import defaultGif from '@/assets/default.gif'
let imgs = []

function setImage(img) {
  img.dom.src = defaultGif // 先暂时使用着默认图片
  // 处理图片
  // 该图片是否在视口范围内
  const clientHeight = document.documentElement.clientHeight
  const { top, imgHeight } = img.dom.getBoundingClientRect()
  const height = imgHeight || 150
  if (top >= -height && top <= clientHeight) {
    // 在视口范围内
    // const tempImg = new Image()
    // tempImg.onload = function () {
    //   img.dom.src = img.src
    // }
    // tempImg.src = img.src
    img.dom.src = img.src
    imgs = imgs.filter(i => i !== img)
  }
}

// 希望，调用该函数，就可以设置那些合适的图片
function setImages() {
  for (const img of imgs) {
    setImage(img)
  }
}

function handleScroll() {
  setImages()
}

$bus.$on('mainScroll', debounce(handleScroll, 100))

export default {
  inserted(el, bindings) {
    const img = {
      dom: el,
      src: bindings.value,
    };
    imgs.push(img);
    // 立即处理它
    setImage(img);
  },
  unbind(el) {
    imgs = imgs.filter((img) => img.dom !== el);
  },
};
```

使用

```html
<img v-lazy="it.thumb" :alt="it.title" :title="it.title" />
```



### loading

创建

```js
import loadingUrl from '@/assets/loading.svg';
import style from './loading.module.less'
function getLoadingImg(el){
  return el.querySelector('img[data-role=loading]')
}
function createLoadingImg(){
  const img =  document.createElement('img')
  img.dataset.role = 'loading'
  img.src = loadingUrl
  img.className = style.loading
  return img
}
export default function (el, binding){
  const curImg = getLoadingImg(el)
  if(binding.value){
    if(!curImg){
       const img = createLoadingImg()
       el.appendChild(img)
    }
  }else{
    if(curImg) curImg.remove()
  }
}
```

使用

```html
<div class="project-container" v-loading="loading">
</div>
```



## 中央事件总线

```js
import Vue from 'vue'
/*
 * 事件名：mainScroll
 * 含义：主区域滚动条位置变化后触发
 * 参数：
 * - 滚动的dom元素，如果是undefined，则表示dom元素已经不存在
 *
 * 事件名：setMainScroll
 * 含义：当需要设置主区域滚动条位置时触发
 * 参数：
 * - 滚动高度
 */
const app = new Vue({})
Vue.prototype.$bus =  app

export default app
```



## $listeners

> `$listeners`是`vue`的一个实例属性，它用于获取父组件传过来的所有事件函数



```html
<!-- 父组件 -->
<Child @event1="handleEvent1" @event2="handleEvent2" />
```



```js
// 子组件
this.$listeners // { event1: handleEvent1, event2: handleEvent2 }
```

> `$emit`和`$listeners`通信的异同
>
> 相同点：均可实现子组件向父组件传递消息
>
> 差异点：
>
> - `$emit`更加符合单向数据流，子组件仅发出通知，由父组件监听做出改变；而`$listeners`则是在子组件中直接使用了父组件的方法。
> - 调试工具可以监听到子组件`$emit`的事件，但无法监听到`$listeners`中的方法调用。（想想为什么）
> - 由于`$listeners`中可以获得传递过来的方法，因此调用方法可以得到其返回值。但`$emit`仅仅是向父组件发出通知，无法知晓父组件处理的结果

> 对于上述中的第三点，可以在`$emit`中传递回调函数来解决
>
> 父组件：
>
> ```vue
> <template>
> <Child @click="handleClick" />
> </template>
> 
> <script>
> import Child from "./Child"
> export default {
>  components:{
>    Child
>  },
>  methods:{
>    handleClick(data, callback){
>      console.log(data); // 得到子组件事件中的数据
>      setTimeout(()=>{
>        callback(1); // 一段时间后，调用子组件传递的回调函数
>      }, 3000)
>    }
>  }
> }
> </script>
> ```
>
> 子组件：
>
> ```vue
> <template>
> <button @click="handleClick">
>  click
> </button>
> </template>
> 
> <script>
> export default {
>  methods:{
>    handleClick(){
>      this.$emit("click", 123, (data)=>{
>        console.log(data); // data为父组件处理完成后得到的数据
>      })
>    }
>  }
> }
> </script>
> ```



## mock的使用

```js
// index.js
import "./banner";
import "./blog";
import "./setting";
import "./about"
import "./project"
import "./message"
import Mock from "mockjs";
Mock.setup({
  timeout: "700-1200",
});
```

```js
Mock.mock("/api/about", "get", {
  code: 0,
  msg: "",
  data: "http://skill.phodal.com/#_rs2tu_1_Name"
});

Mock.mock("/api/banner", "get", {
  code: 0,
  msg: "",
  data: [
    {
      id: "1",
      midImg: "http://mdrs.yuanjin.tech/img/20201031141507.jpg",
      bigImg: "http://mdrs.yuanjin.tech/img/20201031141350.jpg",
      title: "凛冬将至",
      description: "人唯有恐惧的时候方能勇敢",
    },
  ],
});

import qs from 'querystring'
Mock.mock(/^\/api\/blog(\?.+)?$/, "get", function (options) {
  const query = qs.parse(options.url)
  return Mock.mock({
    code: 0,
    msg: "",
    data: {
      "total|2000-3000": 0,
      [`rows|${query.limit || 10}`]: [
        {
          id: "@guid",
          title: "@ctitle(2, 20)",
          description: "@cparagraph(1, 10)",
          category: {
            "id|1-10": 0,
            name: "分类@id",
          },
          "scanNumber|0-3000": 0,
          "commentNumber|0-300": 30,
          "thumb|1": [
            `@image(300x250, @color, #fff, @natural)`, 
            null
          ],
          createDate: Mock.Random.date('yyyy-MM-dd'),
        },
      ],
    },
  });
});

Mock.mock("/api/blogtype", "get", {
  code: 0,
  msg: "",
  "data|10-20": [
    {
      "id|+1": 1,
      name: "分类@id",
      "articleCount|0-200": 0,
      "order|+1": 1
    }
  ],
});
```



## 异步组件

> 只会第一次加载

```js
import "nprogress/nprogress.css";
import { start, done, configure } from "nprogress";
configure({
  trickleSpeed: 20,
  showSpinner: false,
});

function getPageComponent(pageCompResolver){
  return async () => {
    start();
    const comp = await pageCompResolver();
    done();
    return comp;
  }
}
```



```js
  {
    name: "Home",
    path: "/",
    component: getPageComponent(() => import(/* webpackChunkName: "Home" */'@/views/Home')),
    meta: {
      title: "首页",
    },
  },
```



## 快速导入导出

```js
export {default as showMessage} from './showMessage'

export {default as getComponentRootDom} from './getComponentRootDom'

export {default as debounce} from './debounce'

export {default as titleController} from './titleController'
```

使用

```js
import { showMessage } from './utils';
```



## 优化

打包分析

```js
const BundleAnalyzerPlugin = require("webpack-bundle-analyzer").BundleAnalyzerPlugin;
// vue.config.js
module.exports = {
  // 通过 configureWebpack 选项，可对 webpack 进行额外的配置
  // 该配置最终会和 vue-cli 的默认配置进行合并（webpack-merge）
  configureWebpack: {
    plugins: [new BundleAnalyzerPlugin()]
  },
};
```



CDN

> CDN全称为Content Delivery Network，称之为内容分发网络

```js
// vue.config.js
module.exports = {
  configureWebpack: {
    externals: {
      vue: "Vue",
      vuex: "Vuex",
      "vue-router": "VueRouter",
    }
  },
};
```

```html
<script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/vuex/3.5.1/vuex.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/vue-router/3.4.7/vue-router.min.js"></script>
```



启用现代模式

> 利用`vue-cli`提供的命令：

```js
vue-cli-service build --modern
```

