# “老司机” 也会在闭包上翻车



## 前言



​		闭包是 JavaScript 中最基本也是最重要的概念之一，很多开发者都对它 “了如指掌” 。可是闭包又绝对不是一个单一概念：它涉及 `作用域`、`作用域链`、`执行上下文`、`内存管理`等多重知识点。不管是新手还是“；老司机”，经常会出现 “我觉得我弄懂了闭包，但还是会在一下场景下翻车” 的情况。接下来我们要通过 ”应试题“ 来强化理解闭包。





## 基础知识

​		如同前面所说的，闭包不是一个单一概念，在直击闭包之前，先了解一下与之相关的必备知识点。



### 作用域

​		作用域可以被理解为某种规定下的限定范围，该规则用于知道开发者如何在替丁场景下查找变量。在 ES6 出现之前，一般来说只有函数作用域和全局作用域之分。



##### 函数作用域和全局作用域

​		大家应该非常熟悉函数作用域了。例如，执行以下 foo 函数时，变量 a 在函数 foo 的作用域内，因此可以在函数体内正常访问变量 a ，并输出 bar

```js
function foo() {
  var a = "bar"
  console.log(a)  // bar
}
foo()
```



对上述代码稍加改动 ↑ ，使其变为如下形式。↓

```js
var b = 'bar'
function foo() {
	console.log(b) // bar
}
foo()
```

​		执行以上代码时，foo 函数在自身函数作用域内并未查找到 b 变量，但是他会继续向外扩大查找范围，于是便在全局作用域中找到了 b ，并输出 bar



​		如果再对上述代码稍加改动，使其变成如下形式，结果又将如何？

```js
function bar() {
  var b = 'bar'
}
function foo() {
  console.log(b) // undefined
}
foo()
```

​		在上述代码中，foo和bar 分属两个独立的函数作用域，foo 函数无法访问 bar 函数中的变量，且foo作用域链内（直到上层全局作用域中）也不存在相应的变量，因此执行这段代码会报错 `Uncaught ReferenceError: b is not defined`





​		简单总结一下，在JavaScript中执行某个函数时，如果遇见变量且需要读取其值，就会 “就近” 先在函数内部查找该变量的声明或赋值情况。如果在函数内无法找到该变量，就要跳出函数作用域，到更上层作用域中查找。这里的 “更上层作用域” 可能是函数作用域。

​		下面来看一下具体示例 ↓

```js
var a = '1'
function bar() {
  var b = '2'
  function foo() {
    console.log(b) // b  在上层 函数作用域 中找到 b
    console.log(a) // a  在上层 全局作用域 中找到 a
	}
  foo()
}
bar()
```

​		执行上述代码会输出 2、1 ，函数 foo 中的变量 先在 foo函数内查找，没有找到，就扩大查找范围，向上一层 bar 函数中查找，当 b 找到时就停止查找，并输出 2 。a 变量 没有在bar函数中找到 a ，则继续向上查找， 在最外层全局作用域中找到了 a ，并输出 1。 变量在作用域中查找是一个扩散过程，就像各个环节相扣的链条，逐次递进，这就是 `“作用域链”` 的由来。



##### 块级作用域 和 暂时性死区

​		ES6中增加了通过 let 和 const 声明变量的块级作用域，使得 JavaScript 中的作用域内涵更加丰富。这个特性也增加了一定复杂度，带来了 “暂时性死区” 新的概念。说到暂时性死区，还需要从 “变量提升” 说起。



来看看下面代码↓

```js
function foo() {
  console.log(bar) // undefined
  var bar = 3
}
foo()
```

​		执行以上代码会输出 undefined，原因是变量 bar 在函数内进行了提升。下面代码和上面代码时等价的。

```js
function foo() {
  var bar
  console.log(bar)
  bar = 3
}
foo()
```

​		但是，在使用 let 对 bar 进行声明时（如下所示 ↓）则会报错 `Uncaught ReferenceError: bar is not defined`

```js
function foo() {
  console.log(bar) // Uncaught ReferenceError: bar is not defined
  let bar = 3
}
foo()
```



​		我们知道，使用 let 或 const 声明变量时会针对这个变量形成一个封闭的块级作用域，在这块级作用域中，如果在声明变量前访问该变量，就会报 `ReferenceError` 错误；在声明变量的后面访问该变量，就可以正常获取值，示例如下。

```js
function foo() {
  let bar = 3
  console.log(bar) // 3
}
foo()
```

​		因此，在相应花括号形成的作用域中存在一个 “死区（TDZ）”，起始于函数开头，终止于相关变量声明语句的所在行。这个范围内无法访问使用 let 或 const 声明的变量。







### 执行上下文

​		执行上下文就是点前代码的执行环境/作用域，和前文介绍的作用域链相辅相成，但又是两个完全不同的概念。直观上看，执行上下文包含了作用域链，同时他们又像是一条河的上下游：有了作用域链，才会有执行上下文的一部分。



##### 代码执行的两个阶段

- 代码 预编译阶段

  预编译阶段是前置阶段，预编译是 JavaScript 中独特的概念，在代码执行前 JavaScript 引擎会做一些 “预先准备工作”。

  

- 代码 执行阶段

  执行阶段的主要任务是执行代码逻辑，执行上下文在这个阶段会全部创建完成。



​		在通过语法分析，确认语法无误之后，便会在预编译阶段对JavaScript 代码中的变量的内存空间进行分配，我们熟悉的变量提升过程便是在此阶段完成的。



对于预编译过程中的一些细节，我们应该注意一下 3 点。

- 在预编译阶段 进行变量声明。
- 在预编译阶段 对变量声明进行提升，但是值是 `undefined`。
- 在预编译阶段 对所有非表达式的函数声明进行提升。

注意：以上 3 点会帮助我们正确理解和判断代码逻辑，下面通过例题来理解上述注意点。



来看看代码吧 ↓

```js
function bar() {
  console.log('1')
}
var bar = function(){
  console.log('2')
}
bar()
```

会输出 2，接着我们调换代码顺序，再来看看代码

```js
var bar = function(){
  console.log('2')
}
function bar() {
  console.log('1')
}
bar()
```

​		以上代码的输出结果依然是 2，因为在预编译阶段虽然对变量 bar 进行了声明，但是不会对其进行赋值；函数 bar 则被创建并提升。在代码执行阶段，变量 bar 才会（通过表达式）被赋值，赋值的内容是函数体为 console.log("2")的函数，输出结果为 2。



​		来看看这道题↓

```js
foo(10)
function foo(num) {
  console.log(foo,'11');  
  foo = num
  console.log(foo,'22'); 
  var foo
}
console.log(foo,'33'); 
foo = 1
console.log(foo,'44');
```

执行上述代码，输出结果如下。

```js
undefined '11'
10 '22'
ƒ foo(num) {
  console.log(foo,'11');  
  foo = num
  console.log(foo,'22'); 
  var foo
} '33'
1 '44'
```

​		在 foo(10)执行时，var foo 会在函数体内进行变量提升，此时执行函数体内的第一行会输出 undefined '11'，执行函数体内的第三行 输出 10 '22' （num已经对变量foo进行了赋值）。接着运行代码，运行到函数体外的 console.log(foo,'33') 时，会输出 foo 函数的内容 （此时的 foo 就是全局下的 foo 函数本身）。最后输出 1 '44'。





​		上题的结论是，作用域在预编译阶段确定，但是作用域链是在执行上下文的创建阶段完生成的，因为函数在掉用时才会开始创建对应的执行上下文。执行上下文包括变量对象、作用域链及this的指向，

> 执行上下文：
>
> - 变量对象
> - 作用域链
> - this的指向



代码执行过程像一条流水线。

第一步 在 预编译阶段 创建变量对象（Variable Object ， VO），此时只是创建，并未赋值。

第二步 在 执行阶段，变量对象会转为激活对象（Active Object，AO），即完成 VO 向 AO 的转换。此时，作用域链也将被确定，它由`当前执行环境的变量对象` 和 `所有外层已经完成的激活对象` 组成。这道工序保证了变量和函数的有序访问，**即如果未在当前作用域中找到变量，则会继续向上查找直到全局作用域。**





### 调用栈

​		在执行一个函数时，如果这个函数又调用了另一个函数，而这 “另一个函数” 又调用了另一个函数，这便形成了一系列的调用栈。我们用代码去了解一下 “调用栈”

代码如下：

```js
function foo1(){
  foo2()
}
function foo2(){
  foo3()
}
function foo3(){
  foo4()
}
function foo4(){
  console.log('foo4');
}
foo1()
```

​		以上代码中的调用关系为（→ ：代表调用） foo1 → foo2 → foo3 → foo4  。

**具体过程：**

foo1 先入栈，紧接着调用 foo2 ，foo2再入栈，以此类推，直到foo4执行完，然后foo4先出栈，foo3再出栈，接着foo2出栈，最后foo1出栈。

这个过程满足先进后出（后进先出）的规则，因此形成调用栈。



我们可以在 Chrome 浏览器中执行以上代码时，通过设置断点可以查看入栈情况

![image-20221111152845019](C:\Users\JS04\AppData\Roaming\Typora\typora-user-images\image-20221111152845019.png)



**注意：**

​		正常讲，在函数执行完毕并出栈时，函数内的局部变量在下一个垃圾回收（GC）节点会被回收，该函数对应的执行上下文将会被销毁，这也正是我们在外界无法访问函数内定义的变量的原因。

​		也就是说，只有在函数执行时，相关函数才可以访问该变量。该变量会在预编译阶段被创建，在执行阶段被激活，在函数执行完毕后，其相关上下文会被销毁。



## 闭包 



终于到了闭包环节！

​		我认为比较容易理解的闭包定义为：函数嵌套函数时，内层函数引用了外层函数作用域下的变量，并且内层函数在全局环境下可访问，进而形成闭包。



我们来看一个简单的示例，代码如下。

```js
function numAdd() {
  let num = 1
  num++
  return () => console.log(num)
}
var getNum = numAdd()
getNum()
```















